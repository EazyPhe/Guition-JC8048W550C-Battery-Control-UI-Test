#include <Arduino.h>
#include "lvgl.h"
#include "display_driver.h" // Adjust if your display driver header has a different name

// Display flush callback for LVGL 8.x
static void display_flush_cb(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p) {
    // You may need to adjust this if you use a different panel handle variable
    extern esp_lcd_panel_handle_t panel_handle;
    if (panel_handle) {
        esp_lcd_panel_draw_bitmap(panel_handle, area->x1, area->y1, area->x2 + 1, area->y2 + 1, color_p);
    } else {
        Serial.println("ERROR: No panel handle available");
    }
    lv_disp_flush_ready(disp_drv);
}

// Helper to fill screen with a color
void fill_screen(lv_color_t color) {
    lv_obj_clean(lv_scr_act());
    lv_obj_t *rect = lv_obj_create(lv_scr_act());
    lv_obj_set_size(rect, LV_HOR_RES, LV_VER_RES);
    lv_obj_set_style_bg_color(rect, color, 0);
    lv_obj_set_style_bg_opa(rect, LV_OPA_COVER, 0);
}

void test_display_colors() {
    Serial.println("Filling screen with RED");
    fill_screen(lv_color_make(0xFF, 0x00, 0x00));
    delay(2000);
    Serial.println("Filling screen with GREEN");
    fill_screen(lv_color_make(0x00, 0xFF, 0x00));
    delay(2000);
    Serial.println("Filling screen with BLUE");
    fill_screen(lv_color_make(0x00, 0x00, 0xFF));
    delay(2000);
}

void setup() {
    Serial.begin(115200);
    lv_init();
    lcd_panel_init(); // Initialize the display

    // Allocate LVGL buffer
    static lv_color_t buf[DISPLAY_WIDTH * 40]; // 40 lines buffer, adjust as needed
    static lv_disp_draw_buf_t draw_buf;
    lv_disp_draw_buf_init(&draw_buf, buf, NULL, DISPLAY_WIDTH * 40);

    // Register LVGL display driver
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = DISPLAY_WIDTH;
    disp_drv.ver_res = DISPLAY_HEIGHT;
    disp_drv.flush_cb = display_flush_cb; // You must have this callback implemented
    disp_drv.draw_buf = &draw_buf;
    lv_disp_drv_register(&disp_drv);

    test_display_colors();
}

void loop() {
    lv_timer_handler();
    delay(5);
}
